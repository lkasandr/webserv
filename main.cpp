#include "webserv.hpp"

int main()
{
	int server_fd = 0;
	int new_socket = 0;
	struct sockaddr_in address; // структура, хранящая информацию об IP-адресе  слущающего сокета




// int socket(int domain, int type, int protocol);

// domain - домен связи, в котором должен быть создан сокет:
// AF_INET      IPv4 Internet protocols                    ip(7)

// type  - тип сервиса. Это выбирается в соответствии со свойствами, требуемыми приложением:
// SOCK_STREAM Обеспечивает последовательные, надежные, двусторонние потоки байтов на основе соединений. Может поддерживаться механизм внеполосной передачи данных.

//protocol:
// указать конкретный протокол, который будет использоваться для поддержки работы сокетов. 
// Это полезно в случаях, когда некоторые семейства могут иметь более одного протокола для поддержки определенного типа службы. 
// Возвращаемое значение - дескриптор файла (маленькое целое число). Аналогия создания розетки - запрос телефонной линии у телефонной компании.
// Для сокетов TCP / IP мы хотим указать семейство IP-адресов (AF_INET) и службу виртуальных каналов (SOCK_STREAM). 
// Поскольку существует только одна форма обслуживания виртуальных каналов, нет никаких вариантов протокола, поэтому последний аргумент, протокол, равен нулю.

	if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		std::cerr << "cannot create socket" << std::endl;
		return 0;
	}

// bind() связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), 
// он ассоциируется с некоторым семейством адресов, но не с конкретным адресом. 
// До того как сокет сможет принять входящие соединения, он должен быть связан с адресом. bind() принимает три аргумента:

// sockfd — дескриптор, представляющий сокет при привязке
// serv_addr — указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
// addrlen — поле socklen_t, представляющее длину структуры sockaddr.
// Возвращает 0 при успехе и −1 при возникновении ошибки.

	std::memset(&address, '0', sizeof(address));
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(INADDR_ANY);
	address.sin_port = htons(PORT);
	if (bind(server_fd, reinterpret_cast<const struct sockaddr*>(&address), sizeof(address)) < 0)
	{
		std::cerr << "bind is failure" << std::endl;
		// closesocket??
		return 0;
	}

	// Прежде чем клиент сможет подключиться к серверу, на сервере должен быть сокет, готовый принимать соединения.
	// listen сообщает сокету, что он должен быть способен принимать входящие соединения:

	// int listen(int s, int backlog);

	// Первый аргумент - сокет для прослушивания, второй аргумент (backlog) - целое положительное число, 
	// определяющее, как много запросов связи может быть принято на сокет одновременно. 
	// В большинстве систем это значение должно быть не больше пяти. 
	// Заметим, что это число не имеет отношения к числу соединений, которое может поддерживаться сервером. 
	// Аргумент backlog имеет отношение только к числу запросов на соединение, которые приходят одновременно. 
	// Число установленных соединений может превышать это число.	


	// Accept используется сервером для принятия связи на сокет. 
	// Сокет должен быть уже слушающим в момент вызова функции. 
	// Если сервер устанавливает связь с клиентом, то функция accept возвращает новый сокет-дескриптор, 
	// через который и происходит общение клиента с сервером. 
	// Пока устанавливается связь клиента с сервером, 
	// функция accept блокирует другие запросы связи с данным сервером, а после установления связи "прослушивание" запросов возобновляется.

	// int accept(int s, char * name, int* anamelen);

	// Первый аргумент функции - сокет-дескриптор для принятия связей от клиентов. 
	// Второй аргумент - указатель на адрес клиента (структура sockaddr ) для соответствующего домена. 
	// Третий аргумент - указатель на целое число - длину структуры адреса. 
	// Второй и третий аргументы заполняются соответствующими значениями в момент установления связи клиента с сервером 
	// и позволяют серверу точно определить, с каким именно клиентом он общается. 
	// Если сервер не интересуется адресом клиента, в качестве второго и третьего аргументов можно задать NULL-указатели.

	if (listen(server_fd, 3) < 0)
	{
		std::cerr << "socket is not listening" << std::endl;
		// closesocket??
		return 0;
	}	

	if ((new_socket = accept(server_fd, (struct sockaddr*)(&address), (socklen_t *)(&address))) < 0)
	{
		std::cerr << "socket is not accept" << std::endl;
		// closesocket??
		return 0;
	}

	const int max_client_buffer_size = 1024;
	char buf[max_client_buffer_size];
	int result = 0;

	result = recv(server_fd, buf, max_client_buffer_size, 0);

	std::stringstream response; // сюда будет записываться ответ клиенту
	std::stringstream response_body; // тело ответа

	if (result == -1)
	{
		std::cerr << "can't read data from socket" << std::endl;
		// closesocket??
		return 0;
	}
	else if (result == 0)
	{
		std::cerr << "connection is closed" << std::endl;
	}
	else if (result > 0) 
	{
		// Мы знаем фактический размер полученных данных, поэтому ставим метку конца строки
		// В буфере запроса.
			buf[result] = '\0';
			
			response_body << "<title>Test C++ HTTP Server</title>\n"
			<< "<h1>Test page</h1>\n"
			<< "<p>This is body of the test page...</p>\n"
			<< "<h2>Request headers</h2>\n"
			<< "<pre>" << buf << "</pre>\n"
			<< "<em><small>Test C++ Http Server</small></em>\n";

		// Формируем весь ответ вместе с заголовками
			response << "HTTP/1.1 200 OK\r\n"
			<< "Version: HTTP/1.1\r\n"
			<< "Content-Type: text/html; charset=utf-8\r\n"
			<< "Content-Length: " << response_body.str().length()
			<< "\r\n\r\n"
			<< response_body.str();

		// Отправляем ответ клиенту с помощью функции send
		result = send(server_fd, response.str().c_str(),
			response.str().length(), 0);

		if (result == -1) 
		{
			// произошла ошибка при отправке данных
			std::cerr << "send failed: " << std::endl;
		}
	}



	return 0;
}