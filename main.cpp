#include "webserv.hpp"

int main()
{
	int server_fd = 0;
	struct sockaddr_in address;

// int socket(int domain, int type, int protocol);

// domain - домен связи, в котором должен быть создан сокет:
// AF_INET      IPv4 Internet protocols                    ip(7)

// type  - тип сервиса. Это выбирается в соответствии со свойствами, требуемыми приложением:
// SOCK_STREAM Обеспечивает последовательные, надежные, двусторонние потоки байтов на основе соединений. Может поддерживаться механизм внеполосной передачи данных.

//protocol:
// указать конкретный протокол, который будет использоваться для поддержки работы сокетов. 
// Это полезно в случаях, когда некоторые семейства могут иметь более одного протокола для поддержки определенного типа службы. 
// Возвращаемое значение - дескриптор файла (маленькое целое число). Аналогия создания розетки - запрос телефонной линии у телефонной компании.
// Для сокетов TCP / IP мы хотим указать семейство IP-адресов (AF_INET) и службу виртуальных каналов (SOCK_STREAM). 
// Поскольку существует только одна форма обслуживания виртуальных каналов, нет никаких вариантов протокола, поэтому последний аргумент, протокол, равен нулю.

	if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		std::cerr << "cannot create socket" << std::endl;
		return 0;
	}

// bind() связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), 
// он ассоциируется с некоторым семейством адресов, но не с конкретным адресом. 
// До того как сокет сможет принять входящие соединения, он должен быть связан с адресом. bind() принимает три аргумента:

// sockfd — дескриптор, представляющий сокет при привязке
// serv_addr — указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
// addrlen — поле socklen_t, представляющее длину структуры sockaddr.
// Возвращает 0 при успехе и −1 при возникновении ошибки.

	std::cout << "1" << std::endl;
	std::memset(&address, '0', sizeof(address));
	std::cout << "2" << std::endl;
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(INADDR_ANY);
	address.sin_port = htons(PORT);
	std::cout << "3" << std::endl;
	if (bind(server_fd, reinterpret_cast<const struct sockaddr*>(&address), sizeof(address)) < 0)
	{
		std::cerr << "bind is failure" << std::endl;
		return 0;
	}



	return 0;
}