#include "webserv.hpp"

int main()
{
	int server_fd = 0;
	int new_socket = 0;
	struct sockaddr_in address;

// int socket(int domain, int type, int protocol);

// domain - домен связи, в котором должен быть создан сокет:
// AF_INET      IPv4 Internet protocols                    ip(7)

// type  - тип сервиса. Это выбирается в соответствии со свойствами, требуемыми приложением:
// SOCK_STREAM Обеспечивает последовательные, надежные, двусторонние потоки байтов на основе соединений. Может поддерживаться механизм внеполосной передачи данных.

//protocol:
// указать конкретный протокол, который будет использоваться для поддержки работы сокетов. 
// Это полезно в случаях, когда некоторые семейства могут иметь более одного протокола для поддержки определенного типа службы. 
// Возвращаемое значение - дескриптор файла (маленькое целое число). Аналогия создания розетки - запрос телефонной линии у телефонной компании.
// Для сокетов TCP / IP мы хотим указать семейство IP-адресов (AF_INET) и службу виртуальных каналов (SOCK_STREAM). 
// Поскольку существует только одна форма обслуживания виртуальных каналов, нет никаких вариантов протокола, поэтому последний аргумент, протокол, равен нулю.

	if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		std::cerr << "cannot create socket" << std::endl;
		return 0;
	}

// bind() связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), 
// он ассоциируется с некоторым семейством адресов, но не с конкретным адресом. 
// До того как сокет сможет принять входящие соединения, он должен быть связан с адресом. bind() принимает три аргумента:

// sockfd — дескриптор, представляющий сокет при привязке
// serv_addr — указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
// addrlen — поле socklen_t, представляющее длину структуры sockaddr.
// Возвращает 0 при успехе и −1 при возникновении ошибки.

	std::cout << "1" << std::endl;
	std::memset(&address, '0', sizeof(address));
	std::cout << "2" << std::endl;
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(INADDR_ANY);
	address.sin_port = htons(PORT);
	std::cout << "3" << std::endl;
	if (bind(server_fd, reinterpret_cast<const struct sockaddr*>(&address), sizeof(address)) < 0)
	{
		std::cerr << "bind is failure" << std::endl;
		return 0;
	}

	// Прежде чем клиент сможет подключиться к серверу, на сервере должен быть сокет, готовый принимать соединения.
	// listen сообщает сокету, что он должен быть способен принимать входящие соединения:

	// int listen(int s, int backlog);

	// Первый аргумент - сокет для прослушивания, второй аргумент (backlog) - целое положительное число, 
	// определяющее, как много запросов связи может быть принято на сокет одновременно. 
	// В большинстве систем это значение должно быть не больше пяти. 
	// Заметим, что это число не имеет отношения к числу соединений, которое может поддерживаться сервером. 
	// Аргумент backlog имеет отношение только к числу запросов на соединение, которые приходят одновременно. 
	// Число установленных соединений может превышать это число.	


	// Accept используется сервером для принятия связи на сокет. 
	// Сокет должен быть уже слушающим в момент вызова функции. 
	// Если сервер устанавливает связь с клиентом, то функция accept возвращает новый сокет-дескриптор, 
	// через который и происходит общение клиента с сервером. 
	// Пока устанавливается связь клиента с сервером, 
	// функция accept блокирует другие запросы связи с данным сервером, а после установления связи "прослушивание" запросов возобновляется.

	// int accept(int s, char * name, int* anamelen);

	// Первый аргумент функции - сокет-дескриптор для принятия связей от клиентов. 
	// Второй аргумент - указатель на адрес клиента (структура sockaddr ) для соответствующего домена. 
	// Третий аргумент - указатель на целое число - длину структуры адреса. 
	// Второй и третий аргументы заполняются соответствующими значениями в момент установления связи клиента с сервером 
	// и позволяют серверу точно определить, с каким именно клиентом он общается. 
	// Если сервер не интересуется адресом клиента, в качестве второго и третьего аргументов можно задать NULL-указатели.

	if (listen(server_fd, 3) < 0)
	{
		std::cerr << "socket is not listening" << std::endl;
		return 0;
	}	

	if ((new_socket = accept(server_fd, (struct sockaddr*)(&address), (socklen_t *)(&address))) < 0)
	{
		std::cerr << "socket is not accept" << std::endl;
		return 0;
	}



	return 0;
}